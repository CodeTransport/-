
在面试一家公司过程中被面试官问道，Thread中的各个方法什么意思，有什么区别？在这里详细记录一下，提高自己的认知。
分别调用Thread.sleep()、Thread.yield()、thread.wait()、thread.wait(100)、thread.join()这几个方法实现功能以及区别。
1>Thread.sleep()

该方法是让当前的线程沉睡，在方法中会设置一个睡眠的时间，单位是毫秒。从调用看出，该方法是Thread类的静态方法，从源码看出，该方法
还是native本地方法。并且该方法会抛出InterruptedException异常。功能是使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁，当时间过了之后，该线程会继续往下进行。sleep()可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

2>Thread.yield()

该方法与sleep()类似，只是不能由用户指定暂停多长时间，并且yield（）方法只能让同优先级的线程有执行的机会。该方法也是线程类的静态本地方法。yield方法会让Thread对象直接从执行（running）状态进入等待执行（runnable）状态，意思就是该方法会使cpu调度该线程改变状态，状态期间
可能会耽误一段时间，也有可能不会存在时间间隔，进入等待执行的线程有可能再次立即从等待执行状态转换为执行状态。

3>thread.wait()

该方法从调用看出，是属于对象的方法，但该方法并不是线程类的特有，是java对象的父类Object的方法，在Object中有三个重载方法，其余两个是
wait(long waitTIme)和wait(long timeout, int nanos)。不带参数的wait方法内部也是调用的wait(0)方法。因此wait() = wait(0)方法。
wait()方法使当前线程暂停执行并释放对象锁标示，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中。当调用notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。

4> thread.join()

该方法属于线程类的特有方法，但是非静态的。在该方法内部也是调用的join(0)方法。在join(long millis)中，当join(0)时等待一个线程直到它死亡,  当join(1000)时等待一个线程1000毫秒后回到主线程继续执行.
